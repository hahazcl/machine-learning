## mysql high capability

### 1.1mysql的逻辑架构

#### 1.3事务

示例:

> 假设一个银行的数据有两张表:支票表(checking)和储蓄表(savings).现在要从用户Jane的支票账户转200美元到她的储蓄账户.

1. 检查支票账户的余额高于200美元
2. 从支票账户余额中减去200美元
3. 在储蓄账户余额中增加200美元

> 要运行的sql语句
>
> 1. start transaction;
> 2. select balance from checking where customer_id = 1000456;
> 3. update checking set balance  = balance -200 where customer_id = 1000456;
> 4. update savings set balance = balance + 200 where customer_id =1000456;
> 5. commit;

除非系统通过严格的ACID测试,否则空谈事务的概念是不够的,ACID表示原子性(atomicity),一致性(consistency),隔离性(isolation),和持久性(durability).

- 原子性(atomicity)
  - 一个事务必须被视为一个不可分割的最小工作单元,整个事务的所有操作要么全部提交成功,要么全部失败回滚,对于一个事务来说,不可能执行其中的一部分,这就是事务的原子性
- 一致性(consistency)
  - 数据库总是从一个一致性的状态转换到另外一个一致性的状态.在银行支付系统中,即使在执行3,4步语句之间,系统崩溃,支票账户也不会损失200美元,因为事务最终没有提交,所以事务中所做的修改也不会保存到数据库中.
- 隔离性(isolation)
  - 通常来说,一个事务所做的修改在最终提交以前,对其他事务是不可见的. 当执行完第3条语句,第4条未执行时,此时有另外一个账户汇总程序开始运行,则其看到的支票余额并没有被减去200美元.
- 持久性(durability)
  - 一旦事务提交,则其所做的修改就永久保存到数据库中.

#### 1.3.1隔离级别

四种隔离级别:

1. **READ UNCOMMITTED** (未提交读)
   - 在READ UNCOMMITTED级别,事务中的修改,即使没有提交,对其他事务也都是可见的.**事务可以读取未提交的数据**,这也被称为**脏读(dirty read)**.
2. **READ COMMITTED**(提交读)
   - 大多数数据库系统的默认隔离级别都是READ COMMITTED(但Mysql不是).READ COMMITTED满足前面提到的隔离性的简单定义: 一个事务开始时,只能"看见"已经提交的事务所做的修改.换句话说,一个事务从开始到提交之前,所做的任何修改对其他事务都是不可见的. 这种隔离级别有时候也叫做**不可重复读(nonrepeatable read)**,因为两次执行同样的查询,得到不一样的结果.
3. **REPEATABLE READ**(可重复读)
   - REPEATABLE READ解决了脏读的问题.该级别保证了在同一个事务中多次读取同样的记录的结果是一致的.但是理论上,可重复读隔离级别还是无法解决另外一个幻读问题.幻读就是: 当某个事务在读取某个范围内的记录时,另外一个事务又在该范围内插入了新的记录,当之前的事务再次读取该范围内的记录时,会产生幻行(Phantom row). InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读问题.
   -  **可重复读是MySQL默认的事务隔离级别** 
4. **SERIALIZABLE**(可串行化)
   - SERIALIZABLE是最高的事务隔离级别.它通过强制事务串行执行,避免了前面所说的幻读问题.简单地说,SERIALIZABLE会在读取的每一行数据上都加锁,所以可能存在大量的超时和锁争用的问题.实际应用中很少用到这个隔离级别,只有在非常需要保证数据的一致性而且可以接受没有并发的情况下,才考虑使用.

#### 1.3.2死锁

死锁是指两个或者多个事务在同一资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象.

